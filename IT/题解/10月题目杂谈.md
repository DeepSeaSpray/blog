

> 2023年10月04日 / 信息学 / 算法

## 美好配对

### 前言
一场互测赛中我出的构造题。

### 题目描述

### 题解

用数组A存储每个拿着饼干的小朋友对于拿着糖的小朋友的好感度序列，指针AT存储每个拿饼干的小朋友的可能伙伴中好感度最大的在序列中的编号。
接着用二维数组B，BIJ表示在拿着糖的第I个小朋友的好感序列中拿着饼干的第J个小朋友的编号。
我们建立一个队列Q，保存所有未找到伙伴的拿饼干的小朋友，最开始我们需要将所有拿着饼干的小朋友加入队列，因为他们都没有伙伴。
接着我们取出队头的小朋友X，并令Y＝AXAT，表示其可能的伙伴中好感度最高的小朋友。如果Y当前有伙伴Z，则比较BYZ和BYX，如果对于Y，X的好感度大于Z那么X成为Y的新伙伴，ATX后移一位，因为Y已不是X可能的伙伴，将其移出队列，并将Z加入队列Q，因为其失去了伙伴Y。
否则ATX后移一位，因为Y以后的伙伴的好感度只会大于Z大于X，所以Y不再是X可能的伙伴。
重复上述操作直到队列Q清空，我们就得到了稳定配对。
如何证明配对一定是稳定的呢？对于一对伙伴AB，因为A按照好感度顺序找伙伴，所以好感度高于B的小朋友对于当前伙伴的好感度一定大于A。对于B来说，A是伙伴竞争中的优胜者，意味着除了A之外的小朋友，要么对当前伙伴好感比B更高，要么B对其的好感小于A。所以AB不会发生不满，配对方案一定是稳定的。
那么，我们一定可以找到稳定配对吗？答案是肯定的。从拿糖的小朋友的角度考虑，因为每个人只有一个伙伴，所以一定有人加入其的伙伴竞争中，他只需要选择最有好感的一个即可。至此我们证明了通过上述方法一定可以找到一个配对，又通过上述方法找到的配对一定是稳定的，所以必定存在一个稳定配对。
再看时间复杂度，最坏情况下每个拿饼干的小朋友只会入队N次，因为其只有N个可能的伙伴，每次入队其可能的伙伴都会减一。所以时间复杂度是N2。