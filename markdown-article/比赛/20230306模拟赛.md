# 20230306模拟赛

## 前言：

考的是牛客的比赛:[https://ac.nowcoder.com/acm/contest/20107](https://ac.nowcoder.com/acm/contest/20107)
今天(星期一)是GDKOI2023停课集训的第二天(其实是停课的第一天,但是是集训的第二天),距离GDKOI2023还有五天(含当天).

## 题解：

### T1 串串串

#### 题目描述

你有两个长度分别为$N$,$M$的01串$S$,$T$,有$Q$次询问,每次询问给出$L_1,R_1,L_2,R_2$,其中$R_1-L_1+1=R_2-L_2+1$令$A=S[L_1,R_1]$,$B=T[L_2,R_2]$,你需要求出$A_i \neq B_i$的位置个数对$2$取模的结果.

#### 解题方法

发现一个性质,对于截取的片段,随便更改字符的顺序,答案不变.

###### 证明：

我们发现如果两个数($0$或$1$)如果相加为$0$则相同,相加为$1$则不同$\pmod 2$.
设两个01串分别为$A$,$B$.则答案为$\Sigma A + \Sigma B$,根据加法交换律很容易得到结论.

所以我们只要做一个前缀和就很容易做出这道题.

### T2方格计数

#### 题目描述

在左下角是 $(0,0)$,右上角是($N$,$M$)的网格上,有$(N+1) \times (M+1)$个格点. 现在要在格点上找$K$个不同的点,使得这些点在一条直线上.并且在这条直线上,相邻点之间的距离不小于$D$.求方案数模$10^9+7$.

> 注:为了习惯,变量名称与原题略有不同.

#### 解题方法

##### 初始想法:

枚举两个点,分别为$(X_1,Y_1)$,$(X_2,Y_2)$.我们设$a=X_1-X_2,b=Y_1-Y_2$,很容易可以得到这条线段上的格点(不包括两个端点)有$g=gcd(a,b)-1$个.我们又知道两个相邻两个点之间的距离不小于$D$,那么选中一个点后相邻的$f=\lceil D \div \sqrt{(a \div g)^2+(b \div g)^2} \rceil$点(包括自己)都不能放球.
所以问题转化成了有一些小球,一些盒子,将小球放入盒子中,使得相邻的两个小球距离不小于$D$的方案数.
怎么做呢?
首先我们的盒子(格点,不包括两个端点)有$g-1$个,我们的每个点之后又需要隔$f-1$个盒子才能再放点(最后一个除外),所以要减去$(f-1) \times (k-3)$,另外的开头之后和结尾之前总共$2 \times (f-1)$个盒子也不能放,所以可选的盒子为$g-1-2 \times (f-1)-(f-1)*(k-3)$个.
然后我们要从中放$K-2$个球(开头和结尾已确定)所以答案为:

$$
C_{g-1-2 \times (f-1)-(f-1)*(k-3)}^{k-2}
$$

但然我们还要判断一些特殊情况:

1. 当$a=0$且$b=0$时:直接跳过
2. 当$f*(k-1) \gt g$时:所需的格点数超过了可以放的格点数,直接跳过
3. 当$i \neq 0$或$j \neq 0$时:有向左下斜的,也有向右下斜的,所以要乘以$2$

##### 优化:

我们其实没有必要枚举两个格点,因为我们只关心$a$,和$b$,所以我们枚举$a$和$b$就好了.
最后答案要乘以$(n-a+1) \times (m-b+1)$

### T3树数树

#### 题目描述

牛牛有一棵$N$个点的有根树,根为$1$,我们称一个长度为$M$的序列$A$是好的,当且仅当:
1.对于相邻的两个数$X$,$Y$,要么$X$是$Y$的祖先,要么$Y$是$X$的祖先
2.所有数都不相等
你需要帮助牛牛求出最长的序列长度。

#### 解题方法

##### 错误解法1:

以为要求$X$,$Y$是父子关系,去求树的直径.

##### 错误解法2:

想到树形DP,设$f[i][1:3]$分别为$i$子树中第一大的,第二大的,第三大的序列长度.那么$i$子树的贡献为$f[i][1]+f[i][2]+1$.求出不同子树中的第一大的,第二大的,第三大的值.
问题是,这样做就限制了选择的两条序列就一定是来自两个不同的子树的,然而事实并不是这样,我们也可以选来自同一个子树的两个序列.

```plain
//一个反例
5
1 2
2 3
2 4
1 7
```

##### 正确解法:

我们使用一个优先队列将$i$子树的所有情况全部保存起来,转移时,将儿子节点的优先队列都合并到自己这里.然后选两个最大的加起来.

##### 代码解读:

```cpp
//定义
struct node{int b, nxt;};
const int maxn= 1e5;
int t;
int n;
node e[maxn*4+5];
int hd[maxn+5],tot;//链式前向星
priority_queue<int> qu[maxn+5];
int id[maxn+5];//i的优先队列编号
int tmp;

inline int merge(int x,int y)//启发式合并
{
    //把较小的合并到较大的优先队列中以减小时间复杂度,可以达到log级别
    if(qu[x].size()>qu[y].size()) swap(x,y);
    while(!qu[x].empty())
    {
        qu[y].push(qu[x].top());
        qu[x].pop();
    }
    return y;//返回合并后的优先队列编号
}

void dfs(int x)
{
    id[x]=x;//x的优先队列编号默认设为x
    while(!qu[id[x]].empty()) qu[id[x]].pop();//先清空
    for (int i = hd[x];i;i=e[i].nxt)//便利子节点
    {
        if(id[e[i].b]!=0) continue;//去过了就跳过
        dfs(e[i].b);
        id[x]=merge(id[x],id[e[i].b]);//合并优先队列
    }
    tmp=1;//一个都没有就是1
    if(!qu[id[x]].empty())//如果有一个以上,就最大的一个加一
    {
        tmp+=qu[id[x]].top();
        qu[id[x]].pop();
    }
    if(!qu[id[x]].empty())//如果有两个以上,就最大的两个加一
    {
        tmp+=qu[id[x]].top();
        qu[id[x]].pop();
    }
    qu[id[x]].push(tmp);//入队
}
```

### 序列

#### 题目描述

定义一个数的 `se`序列为其一个数位和为$10$的子段.
举个例子,$1145141919810900$的所有 `se`序列为:
• $145$
• $451$
• $514$
• $19$
• $91$
• $19$
• $109$
• $1090$
• $10900$
定义一个数是 `ll`数,当且仅当它的每一个数位都在至少一个 `se`序列中.
举个例子,$1145141919810900$不是 `ll`数,因为第一个$1$和$8$不在任何一个 `se`序列中,而$23541901$是一个 `ll`数. 现在牛牛想随机生成一个$[1,10^n)$范围内的数送给牛妹.具体地说,每一位上的数字为$i$的概率为$a_i$,且保证$\sum_{i=0}^{9} a_i=1$现在牛牛想知道这个数为 `ll`数的概率.

#### 解题方法

教练说这题超纲了,所以没做.

## 比赛总结:

第一题很快就看出来了,这本来是优势.但是去死磕第三题,做出了第二种错误解法后,想不通,就放弃了.然后死磕第二题,做出了一个近似的方法,只要再改改式子,加一个特判就过了,但是比赛快结束了,就去第四题骗了$5$分.
总分:$100+0+40+5=145$分,排名第二名.
问题反思:做题太急躁了,没有想清楚就随意换题,考虑问题不够仔细,严谨,时间分配不太合理.以后改正.
